#!/bin/bash 
#iscp
# Copyright (C) 2009 Daniel Liew
#
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
##########################################################################


#Set Defaults
declare -x ISCP_SOURCE=""
declare -x ISCP_TARGET_DIR=${PWD}/
declare -ix ISCP_PORT=22
declare -ix ISCP_RESUME=0
declare -xi ISCP_RETRY=0
declare -x ISCP_VERSION="0.2j"
declare -x ISCP_BW_LIMIT="" #SET THIS TO LIMIT in KB/s, set blank for no limit
declare -xi ISCP_QUOTE=0
declare -xi ISCP_CREATE_SSH_CONTROL_MASTER=1
declare -x ISCP_SSH_CONTROL_PATH="/tmp/$$.iscp.%h-%p" #Specifies location of control socket file for ssh control master. Blank will cause no SSH control master to be used
declare -x ISCP_SSH_MASTER_OPT="-o ServerAliveCountMax=5 -o ServerAliveInterval=20" #Options sent to ssh master if we create it

#declare other variables
declare -x ISCP_SOURCE_SERVER
declare -x ISCP_SOURCE_DIR
declare -ax ISCP_FILE_ARRAY
declare -ax ISCP_USER_CHOICE
declare -ax ISCP_FILE_SIZE_ARRAY
declare -ix ISCP_TICK=0 #LEAVE THIS ALONE IT IS USED FOR PROCESSING STDOUT FROM SSH COMMAND
declare -x ISCP_PARAM_VALUE_REGEX="[]A-Za-z0-9_-:@#!~./% [)(]+$" #SET REGEX (extended) for parsing config file parameter values
declare -x ISCP_PARAM_NAME_REGEX="^[A-Z_]+" #SET REGEX (extended) for parsing config file parameter names
declare -x ISCP_QUOTE_OPT="" #LEAVE THIS ALONE
declare -x ISCP_BW_LIMIT_OPT #LEAVE THIS ALONE
declare -x ISCP_RSYNC_SIGNAL="" #LEAVE THIS ALONE
declare -x ISCP_SSH_CONTROL_PATH_OPT="" #LEAVE THIS ALONE

#start functions
function usage() {
echo "Usage: iscp --help | --iscp-pause | --iscp-unpause | [--bwlimit KBPS] [--config CONFIG_FILE ] [--no-ssh-master | --use-ssh-master SOCKET] [--port PORT] [--quote]  [--resume] [--retry] SOURCE_DIRECTORY TARGET_DIRECTORY

DESCRIPTON
iscp is an interactive version of scp written in BASH using rsync. When iscp is ran it will perform an ls command and a du (--si option) on the remote system and then present the user with a numbered list of files and directories to download (if available). The user then enters a space seperated list of item number(s) the user wishes to download. iscp will then download files/directories in the order specified in the list. If the the file/directory already exists in the target directory then iscp will ask the user what to do (download/resume/skip/quit) unless the --resume option is set. 

OPTIONS

--help
Displays this help message and exits.

--iscp-pause
This will present the user with a list of currently running iscp transfers on the local system and will allow the user to pause them and then exit. Warning this feature is highly experimental. This feature actually sends a -SIGSTOP to rsync.

--iscp-unpause
This will present the user with a list of currently running iscp transfers on the local system and will allow the user to unpause them and exit. Warning this feature is highly experimental. This feature actually sends a -SIGCONT to rsync.

--bwlimit KBPS
Sets a bandwidth in KB/s when downloading files. No limit is applied to the downloading of the file list.

--config CONFIG_FILE
This option allows you to load a configuration file in which you can set various iscp parameters. Any options specified on the command line will overide settings in the configuration file. Details of possible parameters are described in the CONFIGURATION FILE section. 

--no-ssh-master
This will prevent a ``master'' mode ssh connection from being made when iscp starts. This means that all subsequent ssh connections made will be independent from each other and will thus will each request a password unless a different form of automatic authentification is setup like public-key authentification.

--use-ssh-master SOCKET
Use an already established SSH master connection instead of creating one, where the socket file is SOCKET. This can be established by running ``ssh -M -S SOCKET host''. Note the following wildcards are available %h (host), %r (remote login username) and %p (port).

--port PORT
This option allows the user to set the port number to use for ssh connections.

--quote
This option sends the --protect-args option to rsync and is used to prevent the remote shell interpretting special characters in file/directory names (e.g. white space). Warning if the remote system has an old version of rsync that does not support this option then it will fail!


--resume
If iscp finds an existing file/directory in the target directory then iscp will automatically try to resume the file transfer instead of prompting the user for an action.

--retry
This option will force iscp to keep trying to do a file transfer until it receives an error code of 0. This is useful if your connection is dropped because it will automatically try to resume the file transfer. Job suspend can get you out of this (usually CTRL+Z) then kill %JOB_NUMBER .

CONFIGURATION FILE
A configuration file allows you define iscp paramters. The file must be a UNIX text file. The parameter name must match the regular expression $ISCP_PARAM_NAME_REGEX and the paramter value must match the regular expression $ISCP_PARAM_VALUE_REGEX (note these are extended regular expressions to be used with the program grep). If a line does not match then iscp will ignore it. Each paramter must be specified on a seperate line. The format of the configuration file is PARAMETER_NAME=PARAMETER_VALUE . Any line that fits the regular expression will be ignored and could be used as a comment. However it is common practice to use the # symbol at the beginning of a line to indicate it is a comment line so it is recommended you follow this convention.

The following parameters are available:
SOURCE		- specifies source e.g. user@localhost:/home/user/
TARGET_DIR	- specifies local target directory
RESUME		- Boolean (0 or 1). Specifies whether to use --resume option
RETRY		- Boolean (0 or 1). Specifies whether to use --retry option
BW_LIMIT	- Set bandwidth limit in KB/s
QUOTE		- Boolean (0 or 1). Specifies whether to use --quote option
CREATE_SSH_CONTROL_MASTER - Boolean (0 or 1). Specifies whether to create a SSH control master (opposite of --no-ssh-master option)
SSH_CONTROL_PATH - specifies what the path to the SSH control master socket is. If CREATE_SSH_CONTROL_MASTER is set to 0 then you can specify an existing socket like the --use-ssh-master option

An example configuration file might read as follows

#set my source
SOURCE=user@localhost:/home/user
#enable automatic resume
RESUME=1
#set bandwidth limit to 100KB/s
BW_LIMIT=100

LICENSE
COPYRIGHT (C) 2009 Daniel Liew
This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

VERSION: $ISCP_VERSION

ACKNOWLEDGEMENTS: Thanks to Brendan Le Foll for testing and hunting for bugs. Thanks to Mark G. Sobell for writing such a good book.
"
exit 1

}


#Close the ssh master connection if it should of been opened
function ssh-master-exit() {
if [  $ISCP_CREATE_SSH_CONTROL_MASTER -eq 1 ]; then
#try to close the ssh control master
unset IFS; #make sure we are using normal IFS so options to ssh are parsed correctly
echo -ne "\nStoping SSH control master..."
ssh ${ISCP_SSH_CONTROL_PATH_OPT} -O exit ${ISCP_SOURCE_SERVER}
if [ $? -eq 0 ]; then echo "Success"; else echo "Failure!"; fi
fi
}

#returns the socket path with %h substituted for the current host and %p for the current port - data passed on standard input
function socket-path-translate() {
while read input ; do
USERNAME=$(echo "$ISCP_SOURCE_SERVER" | sed 's/\(.\+\)@.\+/\1/' ) #extract username
if [ -z $USERNAME ]; then USERNAME=$(whoami); fi #if there is no username in ISCP_SOURCE_SERVER assume current username
echo "$input" | sed 's/%h/'${ISCP_SOURCE_SERVER#*@}'/' | sed 's/%p/'${ISCP_PORT}'/' | sed 's/%r/'$USERNAME'/'
done;
}

function signal-rsync() {
#check at least 1 copy of iscp is running # fix not show currently running
ISCP_CURRENT_PID=$$
ISCP_CURRENT_PROCESSES=$(pgrep -x iscp)
if [ $( echo "$ISCP_CURRENT_PROCESSES" | grep -v $ISCP_CURRENT_PID | wc -l ) -eq 0 ]; then 
echo "Error: No Running instances of iscp" 1>&2
exit 1
fi

i=0
for pid in $( pgrep -P $( pgrep -d',' -P $(pgrep -d',' iscp)) -x rsync )
do
ISCP_R_PID_LIST[i]=$pid
i=$(( i+1))
done;

#display list with downloading item
echo "Currently running iscp transfers:"
for ((i=0; i<= ${#ISCP_R_PID_LIST[*]} -1; i++)); do
#display array item number and remote location
echo "[$i] " $( ps --no-headers -o cmd -p ${ISCP_R_PID_LIST[i]} | sed 's/^.\+ --\([a-z]\+\) //g' | sed 's/\([^\]\) .\+$/\1/g')
done;

#prompt user for process to send SIGSTOP/SIGCONT to
if [ "$ISCP_RSYNC_SIGNAL" == "-SIGSTOP" ]; then echo -n "Enter Process number(s) (space seperator) to pause or q (quit)?";
elif [ "$ISCP_RSYNC_SIGNAL" == "-SIGCONT" ]; then echo -n "Enter Process number(s) (space seperator) to unpause or q (quit)?"; 
else echo "ERROR: VARIABLE ISCP_RSYNC_SIGNAL DOES NOT SPECIFY VALID SIGNAL!" 2>&1 ; exit 1; fi



read -a ISCP_PROCESS_CHOICE
if [ ${#ISCP_PROCESS_CHOICE[*]} -eq 0 ]; then echo "Error: No process number(s) specified" 1>&2 ; signal-rsync; fi
if [ ${ISCP_PROCESS_CHOICE[0]} == "q" ]; then echo "Quitting..." 1>&2; exit 0; fi

#parse users input (make sure each element of ISCP_PROCESS_CHOICE IS a number and isn't larger than ${#IFS_FILE_ARRAY[*]} -1
for ((i=0; i<= ${#ISCP_PROCESS_CHOICE[*]} -1; i++))
do
if [ $( echo "${ISCP_PROCESS_CHOICE[i]}" | grep -cE '^[0-9]+$' ) -ne 1 ]; then echo "Error: ${ISCP_PROCESS_CHOICE[i]} is not a valid number" 1>&2 ; signal-rsync; break; fi
if [ ${ISCP_PROCESS_CHOICE[i]} -gt $(( ${#ISCP_R_PID_LIST[*]} - 1)) ]; then echo "Error: ${ISCP_PROCESS_CHOICE[i]} is not in the running process list" 1>&2; signal-rsync; break; fi
done

#cycle through user's choices
for ((i=0; i<=${#ISCP_PROCESS_CHOICE[*]} -1; i++))
do
ISCP_TEMP_NO=${ISCP_PROCESS_CHOICE[i]}
if [ "$ISCP_RSYNC_SIGNAL" == "-SIGSTOP" ]; then echo -n "Sending signal -SIGSTOP to PID:" ${ISCP_R_PID_LIST[ISCP_TEMP_NO]} "..." ;fi
if [ "$ISCP_RSYNC_SIGNAL" == "-SIGCONT" ]; then echo -n "Sending signal -SIGCONT to PID:" ${ISCP_R_PID_LIST[ISCP_TEMP_NO]} "..." ;fi

kill $ISCP_RSYNC_SIGNAL ${ISCP_R_PID_LIST[ISCP_TEMP_NO]} 2> /dev/null
if [ $? -eq 0 ]; then echo "Success"; else echo "Failure!"; fi
done
}

function bash-escape() {
# function to read from standard input and append slash to the following shell characters
# [ ] ( ) & ' and whitespace
while read input ; do
echo "$input" | sed 's/ /\\ /g' | sed 's/(/\\(/g' | sed 's/)/\\)/g' | sed 's/&/\\&/g' | sed 's/\[/\\[/g' | sed 's/\]/\\]/g' | sed 's/'\''/\\'\''/g'
done;
}

function user-menu() {

#create options array with file/directory sizes
( for ((i=0; i<= ${#ISCP_FILE_ARRAY[*]} -1; i++)); do echo "[${i}] (${ISCP_FILE_SIZE_ARRAY[i]}) ${ISCP_FILE_ARRAY[i]}"; done; ) | more

#temporary makes space IFS
IFS=$' \t\n'
echo -n "Enter file number(s) (space seperator) or q:"
read -a ISCP_USER_CHOICE
if [ ${#ISCP_USER_CHOICE[*]} -eq 0 ]; then echo "Error: No files specified, type q to quit."; user-menu; fi
if [ ${ISCP_USER_CHOICE[0]} == "q" ]; then echo "Quitting..." 1>&2;  exit 0; fi
#set IFS back
IFS=$'\n'

#parse users input (make sure each element of ISCP_USER_CHOICE IS a number and isn't larger than ${#IFS_FILE_ARRAY[*]} -1
for ((i=0; i<= ${#ISCP_USER_CHOICE[*]} -1; i++))
do
if [ $( echo "${ISCP_USER_CHOICE[i]}" | grep -cE '^[0-9]+$' ) -ne 1 ]; then echo "Error: ${ISCP_USER_CHOICE[i]} is not a valid number" 1>&2 ; user-menu; break; fi
if [ ${ISCP_USER_CHOICE[i]} -gt $(( ${#ISCP_FILE_ARRAY[*]} - 1)) ]; then echo "Error: ${ISCP_USER_CHOICE[i]} is not in the file/directory list" 1>&2; user-menu; break; fi
done

}

function drq-dir-prompt() {
echo "Download directory: ${ISCP_FILE_ARRAY[file_no]}"
echo  -n "Download(d)/Resume(r)/skip(s)/quit(q)?"
read -n1 answer
if [ -z $answer ]; then echo -e "\nPlease choose an option." 1>&2; drq-dir-prompt; fi
case "$answer" in
d|D)
fresh-dir
;;
r|R)
resume-dir
;;
q|Q)
echo -e "\nQuitting..." 1>&2; exit 0;
;;
s|S)
echo -e "\nskip directory ${ISCP_FILE_ARRAY[file_no]}";
;;
*)
echo -e "\nPlease choose a valid option" 1>&2; drq-dir-prompt;
;;
esac

}

function drq-file-prompt() {
echo "Download file: ${ISCP_FILE_ARRAY[file_no]}"
echo  -n "Download(d)/Resume(r)/skip(s)/quit(q)?"
read -n1 answer
if [ -z $answer ]; then echo -e "\nPlease choose an option." 1>&2; drq-file-prompt; fi
case "$answer" in
d|D)
fresh-file
;;
r|R)
resume-file
;;
q|Q)
echo -e "\nQuitting..." 1>&2; exit 0;
;;
s|S)
echo -e "\nskip file ${ISCP_FILE_ARRAY[file_no]}";
;;
*)
echo -e "\nPlease choose a valid option" 1>&2; drq-file-prompt;
;;
esac

}


function fresh-dir() {
echo -e "\nFresh directory download: ${ISCP_FILE_ARRAY[file_no]}"

#if old dir exists then remove it
if [ -d "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ]; then echo -n "removing existing directory..."; rm -r  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ; echo "starting download..."; fi

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi


if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT $ISCP_SSH_CONTROL_PATH_OPT" $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --recursive --partial "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}"
# if rsync fails and user specified --retry retry rsync command indefinitely #FIXED if failed do resume-dir
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "Directory Transfer failure...retrying" 1>&2; resume-dir; fi
}

function resume-dir() {
echo -e "\nResume directory download: ${ISCP_FILE_ARRAY[file_no]}"

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi

if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT $ISCP_SSH_CONTROL_PATH_OPT"  $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --partial --recursive  "$ISCP_ESC_SOURCE"  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "Directory Transfer failure...retrying" 1>&2; resume-dir; fi
}

function fresh-file() {
echo -e "\nFresh file download: ${ISCP_FILE_ARRAY[file_no]}"

#if old file exists then remove it
if [ -f "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ]; then echo -n "removing existing file..."; rm  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ; echo "starting download..."; fi

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi

if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT $ISCP_SSH_CONTROL_PATH_OPT"  $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --partial "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}"
# if rsync fails and user specified --retry retry rsync command indefinitely #FIXED if failed do resume-fil
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "File Transfer failure...retrying" 1>&2; resume-file; fi
}

function resume-file() {
echo -e "\nResume file download: ${ISCP_FILE_ARRAY[file_no]}"

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi


if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT $ISCP_SSH_CONTROL_PATH_OPT"  $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --partial  "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "File Transfer failure...retrying" 1>&2; resume-file; fi
}
#end functions

#start program

#check for a config file option and load its options (we do this before processing other command line arguments so they can overwrite config file)
for ((i=1; i<=$#; i++)); do

#check for --config argument
if [ "${!i}" == "--config" ]; then
i=$((i+1))
if [ -r "${!i}" -a -f "${!i}"  ]; then
#user has read permission for config file that exists and is a file
echo "Reading configuration file: ${!i}";
while read option; do
#check line contains iscp setting
if [ $( echo "$option" | grep -Ec "${ISCP_PARAM_NAME_REGEX}=${ISCP_PARAM_VALUE_REGEX}" ) -eq 1 ]; then
#we've found an option set it
echo "Setting...${option}"
eval  ISCP_$( echo "$option" | grep -Eo "$ISCP_PARAM_NAME_REGEX" )=\"$(echo "$option" | grep -Eo "$ISCP_PARAM_VALUE_REGEX" )\"
fi

done <<< "$(cat ${!i})"


else echo "Error: configuration file ${!i} is not readable!" 1>&2; exit; fi
fi

done


#cycle through commandline arguments
for ((i=1; i<=$#; i++))
do

#check for sourcedir and target dir arguments
if [ $(($# - 1)) -eq $i -a $(echo ${!i} | cut -c1,2 ) != "--" -a $(echo ${!#} | cut -c1,2) != "--" ]; then ISCP_SOURCE=${!i}; i=$((i+1)); ISCP_TARGET_DIR=${!i}; fi

#check for --resume argument
if [ ${!i} == "--resume" ]; then ISCP_RESUME=1; fi

#check for --help argument
if [ ${!i} == "--help" ]; then usage; fi 

#check for --iscp-pause argument
if [ ${!i} == "--iscp-pause" ]; then ISCP_RSYNC_SIGNAL="-SIGSTOP"; signal-rsync; exit ; fi

#check for --iscp-unpause argument
if [ ${!i} == "--iscp-unpause" ]; then ISCP_RSYNC_SIGNAL="-SIGCONT"; signal-rsync; exit ; fi

#check for --no-ssh-master argument
if [ ${!i} == "--no-ssh-master" ]; then ISCP_CREATE_SSH_CONTROL_MASTER=0; ISCP_SSH_CONTROL_PATH_OPT="";fi

#check for --use-ssh-master argument
if [ ${!i} == "--use-ssh-master" ]; then
	i=$((i +1));
	ISCP_SSH_CONTROL_PATH=${!i};
	ISCP_CREATE_SSH_CONTROL_MASTER=0;
	if [ -S "$ISCP_SSH_CONTROL_PATH" ]; then
	#socket exists
	ISCP_SSH_CONTROL_PATH_OPT="-S ${ISCP_SSH_CONTROL_PATH}" #we will use this socket assuming that it is a socket for a master SSH Connection
	echo "Using SSH control master on socket:${ISCP_SSH_CONTROL_PATH}"
	else
	echo "Error socket: ${ISCP_SSH_CONTROL_PATH} cannot be accessed" 1>&2; exit 1;
	fi
fi  

#check for --port argument
if [ ${!i} == "--port" ]; then i=$((i + 1)); 
if [ -z ${!i} ]; then echo "Error: Port number not specified!" 1>&2 ; usage; fi
if [ $( echo "${!i}" | grep -Ec '^[0-9]+$') -ne 1 ]; then echo "Error: Port number is invalid!" 1>&2; usage; fi
ISCP_PORT=${!i}; 
fi

#check for --bwlimit argument
if [ ${!i} == "--bwlimit" ]; then i=$((i +1));
if [ $( echo "${!i}" | grep -Ec '^[0-9]+$') -ne 1 ]; then echo "Error: Bandwidth limit is invalid!" 1>&2; usage; fi
ISCP_BW_LIMIT="${!i}"
fi

#check for --quote argument
if [ ${!i} == "--quote" ]; then ISCP_QUOTE=1; fi


#check for retry option
if [ ${!i} == "--retry" ]; then ISCP_RETRY=1; fi


done

#set bandwidth limit option if necessary
if [ ! -z "$ISCP_BW_LIMIT" ]; then ISCP_BW_LIMIT_OPT="--bwlimit=${ISCP_BW_LIMIT}"; else ISCP_BW_LIMIT_OPT=""; fi

#set ISCP_QUOTE_OPT if necessary
if [ $ISCP_QUOTE -eq 1 ]; then ISCP_QUOTE_OPT="--protect-args"; fi

#command line parameter parsing finished

#add check for ssh, rsync
if [ $(which ssh | wc -m) -eq 0 ]; then echo "Error: ssh command cannot be found in PATH, it may not be installed." 1>&2; exit 1; fi
if [ $(which rsync | wc -m) -eq 0 ]; then echo "Error: rsync cannot be found in PATH, it may not be installed." 1>&2; exit 1; fi


#append trailing slash to source dir and target dir if necessary
if [ $( echo "$ISCP_SOURCE" | grep -c "/$") -eq 0 ]; then ISCP_SOURCE=${ISCP_SOURCE}/ ; fi
if [ $( echo "$ISCP_TARGET_DIR" | grep -c "/$") -eq 0 ]; then ISCP_TARGET_DIR=${ISCP_TARGET_DIR}/ ; fi

#check format of ISCP_SOURCE is correct (only a rough check)
if [ $( echo "$ISCP_SOURCE" | grep -Eci '^([a-z0-9_-]+@)?[0-9a-z.-]+:[0-9a-z/ _.-]+$') -ne 1 ]; then echo "Error: source directory is invalid, format must be [user@]hostname:/path/to/directory" 1>&2; exit; fi

#check target directory exists
if [ ! -d "$ISCP_TARGET_DIR" ]; then echo "Error: target directory does not exist" 1>&2; exit 1; fi
#check target directory is writable
if [ ! -w "$ISCP_TARGET_DIR" ]; then echo "Error: target directory is not writable" 1>&2; exit 1; fi


#get ISCP_SOURCE_SERVER & ISCP_SOURCE_DIR
ISCP_SOURCE_SERVER=$(echo "$ISCP_SOURCE" | sed 's/:.*//g')
ISCP_SOURCE_DIR=$(echo "$ISCP_SOURCE" | sed 's/.*://g')

#setup ISCP_SSH_CONTROL_PATH_OPT if ISCP_SSH_CONTROL_PATH isn't blank
if [ ! -z "$ISCP_SSH_CONTROL_PATH" ]; then
ISCP_SSH_CONTROL_PATH_OPT="-S ${ISCP_SSH_CONTROL_PATH}"
else
ISCP_SSH_CONTROL_PATH_OPT=""; #no SSH control master will be used by iscp
fi

#############main begin

#get directory listing from remote server
echo "Connecting to $ISCP_SOURCE_SERVER on port $ISCP_PORT in ${ISCP_SOURCE_DIR}"

#setup master ssh connection for all other ssh commands to use.
if [ $ISCP_CREATE_SSH_CONTROL_MASTER -eq 1 ]; then
	#start ssh control master, it needs to perform a command so it can go to background. The command is an infinite loop
	ssh -M $ISCP_SSH_CONTROL_PATH_OPT $ISCP_SSH_MASTER_OPT -p $ISCP_PORT -f  "${ISCP_SOURCE_SERVER}" "while true; do sleep 10m; done;" 
	if [ $? -eq 0 ]; then 
		echo -n "SSH Control master started..."
		ssh ${ISCP_SSH_CONTROL_PATH_OPT} -O check ${ISCP_SOURCE_SERVER} #Display information about control server
		echo "Socket:$(echo $ISCP_SSH_CONTROL_PATH | socket-path-translate)"
		#setup trap so certain kill signals make sure ssh master gets killed so we don't leave gapping security hole!
		trap ssh-master-exit 0;
	else
		echo "Failed to setup ssh control master." 1>&2; exit 1; 
	fi
fi

#perform an additional error check of the SSH_CONTROL_PATH
if [ ! -z "$ISCP_SSH_CONTROL_PATH" -a ! -S $(echo "$ISCP_SSH_CONTROL_PATH" | socket-path-translate ) ]; then
echo "SSH control master socket:" $(echo "$ISCP_SSH_CONTROL_PATH" | socket-path-translate) "does not exist!" 1>&2; exit 1;
fi

#get ls listing & size with single ssh command
#cycle through elements and create array
i=0
j=0
ISCP_FOD_OUTPUT=$(ssh -p $ISCP_PORT $ISCP_SSH_CONTROL_PATH_OPT $ISCP_SOURCE_SERVER "ls -F '${ISCP_SOURCE_DIR}' ; echo '##END-LS##'; cd '$ISCP_SOURCE_DIR' ; du --si --max-depth=0 *")

#change IFS to allow filenames/directory names with spaces to processed
IFS=$'\n'
for fod in $ISCP_FOD_OUTPUT 
do
if [ $fod == "##END-LS##" ]; then ISCP_TICK=1; continue;fi

#extract ls -F command
if [ $ISCP_TICK -eq 0 ]; then
ISCP_FILE_ARRAY[i]=$fod
i=$((i+1))
fi

#extract du --si --max-depth=0 command
if [ $ISCP_TICK -eq 1 ]; then
ISCP_FILE_SIZE_ARRAY[j]=$(echo "$fod" | awk '{print $1}' )
j=$((j+1))
fi

done


#check to see we actually found stuff to download
if [ ${#ISCP_FILE_ARRAY[*]} -eq 0 ]; then echo "Error: Nothing to Download!" 1>&2;  exit 1; fi


#show user menu 
user-menu

# ISCP_USER_CHOICE now contains a list of the indicies to use in ISCP_FILE_ARRAY, cycle through them and take appropriate action
for (( i=0; i<= ${#ISCP_USER_CHOICE[*]} -1; i++))
do
file_no=${ISCP_USER_CHOICE[i]}
echo "Download : ${ISCP_FILE_ARRAY[file_no]}"

#decide if we are dealing with a file or directory
if [ $( echo ${ISCP_FILE_ARRAY[file_no]} | grep -c '/$') -eq 1 ]; then
##directory download

#check if directory already exists in target directory
if [ -d ${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]} ]; then
#directory already exists on local system

#decide to use user input if --auto is set to 0
if [ $ISCP_RESUME -eq 1 ]; then resume-dir; else
#bring up prompt to ask user what to do
drq-dir-prompt
fi

else
#directory in new do freshdir download
fresh-dir
fi

##end directory download
else
##file download

#check if file already exists in target directory
if [ -f ${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]} ]; then
#file already exists on local system

#decide to use user input if --auto is set to 0
if [ $ISCP_RESUME -eq 1 ]; then resume-file; else
#bring up prompt to ask user what to do
drq-file-prompt
fi

else
#file is new do freshfile
fresh-file
fi



##end file download
fi

done

echo "Done..."
#We assume the trap set earlier will cause function ssh-master-exit to be called
###############main end

