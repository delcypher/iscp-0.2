#!/bin/bash 
#iscp
# Copyright (C) 2009 Daniel Liew
#
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
##########################################################################


#Set Defaults
declare -x ISCP_SOURCE=""
declare -x ISCP_TARGET_DIR=${PWD}/
declare -ix ISCP_PORT=22
declare -x ISCP_RESUME=0
declare -xi ISCP_SSH_AGENT=0
declare -x ISCP_IDENTITY_FILE=""
declare -xi ISCP_RETRY=0
declare -x ISCP_VERSION="0.2i"
declare -x ISCP_BW_LIMIT="" #SET THIS TO LIMIT in KB/s, set blank for no limit
declare -x ISCP_QUOTE=0

#declare other variables
declare -x ISCP_SOURCE_SERVER
declare -x ISCP_SOURCE_DIR
declare -ax ISCP_FILE_ARRAY
declare -ax ISCP_USER_CHOICE
declare -ax ISCP_FILE_SIZE_ARRAY
declare -ix ISCP_TICK=0 #LEAVE THIS ALONE IT IS USED FOR PROCESSING STDOUT FROM SSH COMMAND
declare -x ISCP_PARAM_VALUE_REGEX="[]A-Za-z0-9_-:@#!~./ [)(]+$" #SET REGEX (extended) for parsing config file parameter values
declare -x ISCP_PARAM_NAME_REGEX="^[A-Z_]+" #SET REGEX (extended) for parsing config file parameter names
declare -x ISCP_QUOTE_OPT="" #LEAVE THIS ALONE
declare -x ISCP_BW_LIMIT_OPT #LEAVE THIS ALONE
declare -x ISCP_RSYNC_SIGNAL="" #LEAVE THIS ALONE

#start functions
function usage() {
echo "Usage: iscp --help | --iscp-pause | --iscp-unpause | [--bwlimit KBPS] [--config CONFIG_FILE ] [--port PORT] [--quote] [--ssh-agent [IDENTITY_FILE] ] [--resume] [--retry] SOURCE_DIRECTORY TARGET_DIRECTORY

DESCRIPTON
iscp is an interactive version of scp written in BASH using rsync. When iscp is ran it will perform an ls command and a du (--si option) on the remote system and then present the user with a numbered list of files and directories to download (if available). The user then enters a space seperated list of item number(s) the user wishes to download. iscp will then download files/directories in the order specified in the list. If the the file/directory already exists in the target directory then iscp will ask the user what to do (download/resume/skip/quit) unless the --resume option is set. 

OPTIONS

--help
Displays this help message and exits.

--iscp-pause
This will present the user with a list of currently running iscp transfers on the local system and will allow the user to pause them and then exit. Warning this feature is highly experimental. This feature actually sends a -SIGSTOP to rsync.

--iscp-unpause
This will present the user with a list of currently running iscp transfers on the local system and will allow the user to unpause them and exit. Warning this feature is highly experimental. This feature actually sends a -SIGCONT to rsync.

--bwlimit KBPS
Sets a bandwidth in KB/s when downloading files. No limit is applied to the downloading of the file list.

--config CONFIG_FILE
This option allows you to load a configuration file in which you can set various iscp parameters. Any options specified on the command line will overide settings in the configuration file. Details of possible parameters are described in the CONFIGURATION FILE section. 

--port PORT
This option allows the user to set the port number to use for ssh connections.

--quote
This option sends the --protect-args option to rsync and is used to prevent the remote shell interpretting special characters in file/directory names (e.g. white space). Warning if the remote system has an old version of rsync that does not support this option then it will fail!

--ssh-agent [IDENTITY_FILE]
This option loads ssh-agent and loads the identity file specified. If no identity file is specified then the user's default identites will be loaded. After iscp has finished executing the ssh-agent will be terminated. This option is useful if you have a key setup between your machine and the target machine as you will only need to enter your passphrase once.

--resume
If iscp finds an existing file/directory in the target directory then iscp will automatically try to resume the file transfer instead of prompting the user for an action.

--retry
This option will force iscp to keep trying to do a file transfer until it receives an error code of 0. This is useful if your connection is dropped because it will automatically try to resume the file transfer. Job suspend can get you out of this (usually CTRL+Z) then kill %JOB_NUMBER .

CONFIGURATION FILE
A configuration file allows you define iscp paramters. The file must be a UNIX text file. The parameter name must match the regular expression $ISCP_PARAM_NAME_REGEX and the paramter value must match the regular expression $ISCP_PARAM_VALUE_REGEX (note these are extended regular expressions to be used with the program grep). If a line does not match then iscp will ignore it. Each paramter must be specified on a seperate line. The format of the configuration file is PARAMETER_NAME=PARAMETER_VALUE . Any line that fits the regular expression will be ignored and could be used as a comment. However it is common practice to use the # symbol at the beginning of a line to indicate it is a comment line so it is recommended you follow this convention.

The following parameters are available:
SOURCE		- specifies source e.g. user@localhost:/home/user/
TARGET_DIR	- specifies local target directory
RESUME		- Boolean (0 or 1). Specifies whether to use --resume option
SSH_AGENT	- Boolean (0 or 1). Specifies whether to use --ssh-agent option
IDENTITY_FILE	- specifies location of identity file to used with ssh-agent (this has no effect unless --ssh-agent option is set or SSH_AGENT is set in configuration file)
RETRY		- Boolean (0 or 1). Specifies whether to use --retry option
BW_LIMIT	- Set bandwidth limit in KB/s
QUOTE		- Boolean (0 or 1). Specifies whether to use --quote option

An example configuration file might read as follows

#set my source
SOURCE=user@localhost:/home/user
#enable automatic resume
RESUME=1
#set bandwidth limit to 100KB/s
BW_LIMIT=100

LICENSE
COPYRIGHT (C) 2009 Daniel Liew
This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

VERSION: $ISCP_VERSION

ACKNOWLEDGEMENTS: Thanks to Brendan Le Foll for testing and hunting for bugs. Thanks to Mark G. Sobell for writing such a good book.
"
exit 1

}

function kill-ssh-agent() {
#kill ssh-agent if user chose to user it and the PID associated is still active
if [ $ISCP_SSH_AGENT -eq 1 ]; then 
#do seperate if just incase no SSH_AGENT which causes ps to through error as no PID is given to --pid argument
if [ $(ps --pid $SSH_AGENT_PID 2> /dev/null | wc -l) -eq 2 ]; then
echo -n "Killing ssh-agent..."
eval `ssh-agent -k`
if [ $? -eq 0 ]; then echo "success" ; else echo "Failed to kill ssh-agent PID: $SSH_AGENT_PID" 1>&2; fi

fi
fi
}

function signal-rsync() {
#check at least 1 copy of iscp is running # fix not show currently running
ISCP_CURRENT_PID=$$
ISCP_CURRENT_PROCESSES=$(pgrep -x iscp)
if [ $( echo "$ISCP_CURRENT_PROCESSES" | grep -v $ISCP_CURRENT_PID | wc -l ) -eq 0 ]; then 
echo "Error: No Running instances of iscp" 1>&2
exit 1
fi

i=0
for pid in $( pgrep -P $( pgrep -d',' -P $(pgrep -d',' iscp)) -x rsync )
do
ISCP_R_PID_LIST[i]=$pid
i=$(( i+1))
done;

#display list with downloading item
echo "Currently running iscp transfers:"
for ((i=0; i<= ${#ISCP_R_PID_LIST[*]} -1; i++)); do
#display array item number and remote location
echo "[$i] " $( ps --no-headers -o cmd -p ${ISCP_R_PID_LIST[i]} | sed 's/^.\+ --\([a-z]\+\) //g' | sed 's/\([^\]\) .\+$/\1/g')
done;

#prompt user for process to send SIGSTOP/SIGCONT to
if [ "$ISCP_RSYNC_SIGNAL" == "-SIGSTOP" ]; then echo -n "Enter Process number(s) (space seperator) to pause or q (quit)?";
elif [ "$ISCP_RSYNC_SIGNAL" == "-SIGCONT" ]; then echo -n "Enter Process number(s) (space seperator) to unpause or q (quit)?"; 
else echo "ERROR: VARIABLE ISCP_RSYNC_SIGNAL DOES NOT SPECIFY VALID SIGNAL!" 2>&1 ; exit 1; fi



read -a ISCP_PROCESS_CHOICE
if [ ${#ISCP_PROCESS_CHOICE[*]} -eq 0 ]; then echo "Error: No process number(s) specified" 1>&2 ; signal-rsync; fi
if [ ${ISCP_PROCESS_CHOICE[0]} == "q" ]; then echo "Quitting..." 1>&2; exit 0; fi

#parse users input (make sure each element of ISCP_PROCESS_CHOICE IS a number and isn't larger than ${#IFS_FILE_ARRAY[*]} -1
for ((i=0; i<= ${#ISCP_PROCESS_CHOICE[*]} -1; i++))
do
if [ $( echo "${ISCP_PROCESS_CHOICE[i]}" | grep -cE '^[0-9]+$' ) -ne 1 ]; then echo "Error: ${ISCP_PROCESS_CHOICE[i]} is not a valid number" 1>&2 ; signal-rsync; break; fi
if [ ${ISCP_PROCESS_CHOICE[i]} -gt $(( ${#ISCP_R_PID_LIST[*]} - 1)) ]; then echo "Error: ${ISCP_PROCESS_CHOICE[i]} is not in the running process list" 1>&2; signal-rsync; break; fi
done

#cycle through user's choices
for ((i=0; i<=${#ISCP_PROCESS_CHOICE[*]} -1; i++))
do
ISCP_TEMP_NO=${ISCP_PROCESS_CHOICE[i]}
if [ "$ISCP_RSYNC_SIGNAL" == "-SIGSTOP" ]; then echo -n "Sending signal -SIGSTOP to PID:" ${ISCP_R_PID_LIST[ISCP_TEMP_NO]} "..." ;fi
if [ "$ISCP_RSYNC_SIGNAL" == "-SIGCONT" ]; then echo -n "Sending signal -SIGCONT to PID:" ${ISCP_R_PID_LIST[ISCP_TEMP_NO]} "..." ;fi

kill $ISCP_RSYNC_SIGNAL ${ISCP_R_PID_LIST[ISCP_TEMP_NO]} 2> /dev/null
if [ $? -eq 0 ]; then echo "Success"; else echo "Failure!"; fi
done
}

function bash-escape() {
# function to read from standard input and append slash to the following shell characters
# [ ] ( ) & ' and whitespace
while read input ; do
echo "$input" | sed 's/ /\\ /g' | sed 's/(/\\(/g' | sed 's/)/\\)/g' | sed 's/&/\\&/g' | sed 's/\[/\\[/g' | sed 's/\]/\\]/g' | sed 's/'\''/\\'\''/g'
done;
}

function user-menu() {

#create options array with file/directory sizes
( for ((i=0; i<= ${#ISCP_FILE_ARRAY[*]} -1; i++)); do echo "[${i}] (${ISCP_FILE_SIZE_ARRAY[i]}) ${ISCP_FILE_ARRAY[i]}"; done; ) | more

#temporary makes space IFS
IFS=$' \t\n'
echo -n "Enter file number(s) (space seperator) or q:"
read -a ISCP_USER_CHOICE
if [ ${#ISCP_USER_CHOICE[*]} -eq 0 ]; then echo "Error: No files specified, type q to quit."; user-menu; fi
if [ ${ISCP_USER_CHOICE[0]} == "q" ]; then echo "Quitting..." 1>&2; kill-ssh-agent; exit 0; fi
#set IFS back
IFS=$'\n'

#parse users input (make sure each element of ISCP_USER_CHOICE IS a number and isn't larger than ${#IFS_FILE_ARRAY[*]} -1
for ((i=0; i<= ${#ISCP_USER_CHOICE[*]} -1; i++))
do
if [ $( echo "${ISCP_USER_CHOICE[i]}" | grep -cE '^[0-9]+$' ) -ne 1 ]; then echo "Error: ${ISCP_USER_CHOICE[i]} is not a valid number" 1>&2 ; user-menu; break; fi
if [ ${ISCP_USER_CHOICE[i]} -gt $(( ${#ISCP_FILE_ARRAY[*]} - 1)) ]; then echo "Error: ${ISCP_USER_CHOICE[i]} is not in the file/directory list" 1>&2; user-menu; break; fi
done

}

function drq-dir-prompt() {
echo "Download directory: ${ISCP_FILE_ARRAY[file_no]}"
echo  -n "Download(d)/Resume(r)/skip(s)/quit(q)?"
read -n1 answer
if [ -z $answer ]; then echo -e "\nPlease choose an option." 1>&2; drq-dir-prompt; fi
case "$answer" in
d|D)
fresh-dir
;;
r|R)
resume-dir
;;
q|Q)
kill-ssh-agent; echo -e "\nQuitting..." 1>&2; exit 0;
;;
s|S)
echo -e "\nskip directory ${ISCP_FILE_ARRAY[file_no]}";
;;
*)
echo -e "\nPlease choose a valid option" 1>&2; drq-dir-prompt;
;;
esac

}

function drq-file-prompt() {
echo "Download file: ${ISCP_FILE_ARRAY[file_no]}"
echo  -n "Download(d)/Resume(r)/skip(s)/quit(q)?"
read -n1 answer
if [ -z $answer ]; then echo -e "\nPlease choose an option." 1>&2; drq-file-prompt; fi
case "$answer" in
d|D)
fresh-file
;;
r|R)
resume-file
;;
q|Q)
kill-ssh-agent; echo -e "\nQuitting..." 1>&2; exit 0;
;;
s|S)
echo -e "\nskip file ${ISCP_FILE_ARRAY[file_no]}";
;;
*)
echo -e "\nPlease choose a valid option" 1>&2; drq-file-prompt;
;;
esac

}


function fresh-dir() {
echo -e "\nFresh directory download: ${ISCP_FILE_ARRAY[file_no]}"

#if old dir exists then remove it
if [ -d "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ]; then echo -n "removing existing directory..."; rm -r  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ; echo "starting download..."; fi

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi


if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT" $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --recursive --partial "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}"
# if rsync fails and user specified --retry retry rsync command indefinitely #FIXED if failed do resume-dir
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "Directory Transfer failure...retrying" 1>&2; resume-dir; fi
}

function resume-dir() {
echo -e "\nResume directory download: ${ISCP_FILE_ARRAY[file_no]}"

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi

if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT"  $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --partial --recursive  "$ISCP_ESC_SOURCE"  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "Directory Transfer failure...retrying" 1>&2; resume-dir; fi
}

function fresh-file() {
echo -e "\nFresh file download: ${ISCP_FILE_ARRAY[file_no]}"

#if old file exists then remove it
if [ -f "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ]; then echo -n "removing existing file..."; rm  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ; echo "starting download..."; fi

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi

if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT"  $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --partial "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}"
# if rsync fails and user specified --retry retry rsync command indefinitely #FIXED if failed do resume-fil
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "File Transfer failure...retrying" 1>&2; resume-file; fi
}

function resume-file() {
echo -e "\nResume file download: ${ISCP_FILE_ARRAY[file_no]}"

if [ -z $ISCP_QUOTE_OPT ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | bash-escape )
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi


if [ ! -z $ISCP_BW_LIMIT_OPT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT")KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT"  $ISCP_BW_LIMIT_OPT $ISCP_QUOTE_OPT --port $ISCP_PORT --progress --human-readable --partial  "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "File Transfer failure...retrying" 1>&2; resume-file; fi
}
#end functions

#start program

#check for a config file option and load its options (we do this before processing other command line arguments so they can overwrite config file)
for ((i=1; i<=$#; i++)); do

#check for --config argument
if [ "${!i}" == "--config" ]; then
i=$((i+1))
if [ -r "${!i}" -a -f "${!i}"  ]; then
#user has read permission for config file that exists and is a file
echo "Reading configuration file: ${!i}";
while read option; do
#check line contains iscp setting
if [ $( echo "$option" | grep -Ec "${ISCP_PARAM_NAME_REGEX}=${ISCP_PARAM_VALUE_REGEX}" ) -eq 1 ]; then
#we've found an option set it
echo "Setting...${option}"
eval  ISCP_$( echo "$option" | grep -Eo "$ISCP_PARAM_NAME_REGEX" )=\"$(echo "$option" | grep -Eo "$ISCP_PARAM_VALUE_REGEX" )\"
fi

done <<< "$(cat ${!i})"


else echo "Error: configuration file ${!i} is not readable!" 1>&2; exit; fi
fi

done


#cycle through commandline arguments
for ((i=1; i<=$#; i++))
do

#check for sourcedir and target dir arguments
if [ $(($# - 1)) -eq $i -a $(echo ${!i} | cut -c1,2 ) != "--" -a $(echo ${!#} | cut -c1,2) != "--" ]; then ISCP_SOURCE=${!i}; i=$((i+1)); ISCP_TARGET_DIR=${!i}; fi

#check for --resume argument
if [ ${!i} == "--resume" ]; then ISCP_RESUME=1; fi

#check for --help argument
if [ ${!i} == "--help" ]; then usage; fi 

#check for --iscp-pause argument
if [ ${!i} == "--iscp-pause" ]; then ISCP_RSYNC_SIGNAL="-SIGSTOP"; signal-rsync; exit ; fi

#check for --iscp-unpause argument
if [ ${!i} == "--iscp-unpause" ]; then ISCP_RSYNC_SIGNAL="-SIGCONT"; signal-rsync; exit ; fi

#check for --port argument
if [ ${!i} == "--port" ]; then i=$((i + 1)); 
if [ -z ${!i} ]; then echo "Error: Port number not specified!" 1>&2 ; usage; fi
if [ $( echo "${!i}" | grep -Ec '^[0-9]+$') -ne 1 ]; then echo "Error: Port number is invalid!" 1>&2; usage; fi
ISCP_PORT=${!i}; 
fi

#check for --bwlimit argument
if [ ${!i} == "--bwlimit" ]; then i=$((i +1));
if [ $( echo "${!i}" | grep -Ec '^[0-9]+$') -ne 1 ]; then echo "Error: Bandwidth limit is invalid!" 1>&2; usage; fi
ISCP_BW_LIMIT="${!i}"
fi

#check for --quote argument
if [ ${!i} == "--quote" ]; then ISCP_QUOTE=1; fi

#check for identity argument
if [ ${!i} == "--ssh-agent" ]; then ISCP_SSH_AGENT=1;
#see if next argument is the identity file or another option
i=$((i+1))
j=$((i+1))
if [ "$(echo ${!i} | cut -c1,2)"  != "--" -a ! $i -gt $# -a ! $j -eq $# ]; then 
#take IDENTITY_FILE parameter only if in correct place
ISCP_IDENTITY_FILE=${!i}
else
i=$((i-1))
fi
unset j
fi

#check for retry option
if [ ${!i} == "--retry" ]; then ISCP_RETRY=1; fi


done

#set bandwidth limit option if necessary
if [ ! -z "$ISCP_BW_LIMIT" ]; then ISCP_BW_LIMIT_OPT="--bwlimit=${ISCP_BW_LIMIT}"; else ISCP_BW_LIMIT_OPT=""; fi

#set ISCP_QUOTE_OPT if necessary
if [ $ISCP_QUOTE -eq 1 ]; then ISCP_QUOTE_OPT="--protect-args"; fi

#command line parameter parsing finished

#add check for ssh, rsync
if [ $(which ssh | wc -m) -eq 0 ]; then echo "Error: ssh command cannot be found in PATH, it may not be installed." 1>&2; exit 1; fi
if [ $(which rsync | wc -m) -eq 0 ]; then echo "Error: rsync cannot be found in PATH, it may not be installed." 1>&2; exit 1; fi


#load ssh-agent if needed
if [ $ISCP_SSH_AGENT -eq 1 ]; then
echo -n "Loading ssh-agent..."
eval `ssh-agent -s` #load ssh agent
echo -n "Loading identities..."; if [ -z $ISCP_IDENTITY_FILE ]; then echo "Defaults"; else echo $ISCP_IDENTITY_FILE; fi
ssh-add $ISCP_IDENTITY_FILE #load identity file, if blank ssh-add takes user defaults
if [ $? -ne 0 ]; then kill-ssh-agent; fi
fi

#change IFS to allow filenames/directory names with spaces to processed
IFS=$'\n'

#append trailing slash to source dir and target dir if necessary
if [ $( echo "$ISCP_SOURCE" | grep -c "/$") -eq 0 ]; then ISCP_SOURCE=${ISCP_SOURCE}/ ; fi
if [ $( echo "$ISCP_TARGET_DIR" | grep -c "/$") -eq 0 ]; then ISCP_TARGET_DIR=${ISCP_TARGET_DIR}/ ; fi

#check format of ISCP_SOURCE is correct (only a rough check)
if [ $( echo "$ISCP_SOURCE" | grep -Eci '^([a-z0-9_-]+@)?[0-9a-z.-]+:[0-9a-z/ _.-]+$') -ne 1 ]; then echo "Error: source directory is invalid, format must be [user@]hostname:/path/to/directory" 1>&2; exit; fi

#check target directory exists
if [ ! -d "$ISCP_TARGET_DIR" ]; then echo "Error: target directory does not exist" 1>&2; exit 1; fi
#check target directory is writable
if [ ! -w "$ISCP_TARGET_DIR" ]; then echo "Error: target directory is not writable" 1>&2; exit 1; fi


#get ISCP_SOURCE_SERVER & ISCP_SOURCE_DIR
ISCP_SOURCE_SERVER=$(echo "$ISCP_SOURCE" | sed 's/:.*//g')
ISCP_SOURCE_DIR=$(echo "$ISCP_SOURCE" | sed 's/.*://g')

#############main begin

#get directory listing from remote server
echo "Connecting to $ISCP_SOURCE_SERVER on port $ISCP_PORT in ${ISCP_SOURCE_DIR}"


#get ls listing & size with single ssh command
#cycle through elements and create array
i=0
j=0
for fod in $(ssh -p $ISCP_PORT $ISCP_SOURCE_SERVER "ls -F '${ISCP_SOURCE_DIR}' ; echo '##END-LS##'; cd '$ISCP_SOURCE_DIR' ; du --si --max-depth=0 *")
do
if [ $fod == "##END-LS##" ]; then ISCP_TICK=1; continue;fi

#extract ls -F command
if [ $ISCP_TICK -eq 0 ]; then
ISCP_FILE_ARRAY[i]=$fod
i=$((i+1))
fi

#extract du --si --max-depth=0 command
if [ $ISCP_TICK -eq 1 ]; then
ISCP_FILE_SIZE_ARRAY[j]=$(echo "$fod" | awk '{print $1}' )
j=$((j+1))
fi

done


#check to see we actually found stuff to download
if [ ${#ISCP_FILE_ARRAY[*]} -eq 0 ]; then echo "Error: Nothing to Download!" 1>&2; kill-ssh-agent ; exit 1; fi


#show user menu 
user-menu

# ISCP_USER_CHOICE now contains a list of the indicies to use in ISCP_FILE_ARRAY, cycle through them and take appropriate action
for (( i=0; i<= ${#ISCP_USER_CHOICE[*]} -1; i++))
do
file_no=${ISCP_USER_CHOICE[i]}
echo "Download : ${ISCP_FILE_ARRAY[file_no]}"

#decide if we are dealing with a file or directory
if [ $( echo ${ISCP_FILE_ARRAY[file_no]} | grep -c '/$') -eq 1 ]; then
##directory download

#check if directory already exists in target directory
if [ -d ${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]} ]; then
#directory already exists on local system

#decide to use user input if --auto is set to 0
if [ $ISCP_RESUME -eq 1 ]; then resume-dir; else
#bring up prompt to ask user what to do
drq-dir-prompt
fi

else
#directory in new do freshdir download
fresh-dir
fi

##end directory download
else
##file download

#check if file already exists in target directory
if [ -f ${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]} ]; then
#file already exists on local system

#decide to use user input if --auto is set to 0
if [ $ISCP_RESUME -eq 1 ]; then resume-file; else
#bring up prompt to ask user what to do
drq-file-prompt
fi

else
#file is new do freshfile
fresh-file
fi



##end file download
fi

done

echo "Done..."
###############main end

#kill ssh-agent if it was invoked
kill-ssh-agent
