#!/bin/bash   
#iscp
# Copyright (C) 2009 Daniel Liew
#
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
##########################################################################


#Set Defaults

declare -x ISCP_SOURCE=""
declare -x ISCP_TARGET_DIR=${PWD}/
declare -ix ISCP_PORT=22
declare -x ISCP_RESUME=0
declare -xi ISCP_SSH_AGENT=0
declare -x ISCP_IDENTITY_FILE=""
declare -xi ISCP_RETRY=0
declare -x ISCP_VERSION="0.2c"
declare -x ISCP_BW_LIMIT="" #IF YOU NEED TO SET A DEFAULT MUST BE SET e.g. ="--bwlimit=20"
declare -x ISCP_QUOTE="" #LEAVE THIS ALONE

#declare other variables
declare -x ISCP_SOURCE_SERVER
declare -x ISCP_SOURCE_DIR
declare -ax ISCP_FILE_ARRAY
declare -ax ISCP_USER_CHOICE
declare -ax ISCP_FILE_SIZE_ARRAY
declare -ix ISCP_TICK=0 #LEAVE THIS ALONE!

#start functions
function usage() {
echo "Usage: iscp --help | [--bwlimit KBPS] [--port PORT] [--quote] [--ssh-agent [IDENTITY_FILE] ] [--resume] [--retry] [source_directory target_directory]

DESCRIPTON
iscp is an interactive version of scp written in BASH using rsync. When iscp is run it will perform an ls command and a du (--si option) on the remote system and then present the user with a numbered list of files and directories to download (if available). The user then enters a space seperated list of item number(s) the user wishes to download. iscp will then download files/directories in the order specified in the list. If the the file/directory already exists in the target directory then iscp will ask the user what to do (download/resume/skip/quit) unless the --auto option is set. 

OPTIONS

--bwlimit KBPS
Sets a bandwidth in KB/s when downloading files. No limit is applied to the downloading of the file list.

--port PORT
This option allows the user to set the port number to use for ssh connections.

--quote
This option sends the --protect-args option to rsync and is used to prevent the remote shell interpretting special characters in file/directory names (e.g. white space). Warning if the remote system has an old version of rsync that does not support this option then it will fail!

--ssh-agent [IDENTITY_FILE]
This option loads ssh-agent and loads the identity file specified. If no identity file is specified then the user's default identites will be loaded. After iscp has finished executing the ssh-agent will be terminated. This option is useful if you have a key setup between your machine and the target machine as you will only need to enter your passphrase once.

--resume
If iscp finds an existing file/directory in the target directory then iscp will automatically try to resume the file transfer instead of prompting the user for an action.

--retry
This option will force iscp to keep trying to do a file transfer until it receives an error code of 0. This is useful if your connection is dropped because it will automatically try to resume the file transfer. Job suspend can get you out of this (usually CTRL+Z) then kill %JOB_NUMBER .

LICENSE
COPYRIGHT (C) 2009 Daniel Liew
This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

VERSION: $ISCP_VERSION
" 1>&2
exit 1

}

function kill-ssh-agent() {
#kill ssh-agent if user chose to user it and the PID associated is still active
if [ $ISCP_SSH_AGENT -eq 1 -a $(ps --pid $SSH_AGENT_PID | wc -l) -eq 2 ]; then 
echo -n "Killing ssh-agent..."
kill -15 $SSH_AGENT_PID
if [ $? -eq 0 ]; then echo "success" ; else echo "Failed to kill ssh-agent PID: $SSH_AGENT_PID" 1>&2; fi


fi
}

function user-menu() {

#create options array with file/directory sizes
( for ((i=0; i<= ${#ISCP_FILE_ARRAY[*]} -1; i++)); do echo "[${i}] (${ISCP_FILE_SIZE_ARRAY[i]}) ${ISCP_FILE_ARRAY[i]}"; done; ) | more

#temporary makes space IFS
IFS=$' \t\n'
echo -n "Enter file number(s) (space seperator) or q:"
read -a ISCP_USER_CHOICE
if [ ${#ISCP_USER_CHOICE[*]} -eq 0 ]; then echo "Error: No files specified, type q to quit."; user-menu; fi
if [ ${ISCP_USER_CHOICE[0]} == "q" ]; then echo "Quitting..." 1>&2; kill-ssh-agent; exit 0; fi
#set IFS back
IFS=$'\n'

#parse users input (make sure each element of ISCP_USER_CHOICE IS a number and isn't larger than ${#IFS_FILE_ARRAY[*]} -1
for ((i=0; i<= ${#ISCP_USER_CHOICE[*]} -1; i++))
do
if [ $( echo "${ISCP_USER_CHOICE[i]}" | grep -cE '^[0-9]+$' ) -ne 1 ]; then echo "Error: ${ISCP_USER_CHOICE[i]} is not a valid number" 1>&2 ; user-menu; break; fi
if [ ${ISCP_USER_CHOICE[i]} -gt $(( ${#ISCP_FILE_ARRAY[*]} - 1)) ]; then echo "Error: ${ISCP_USER_CHOICE[i]} is not in the file/directory list" 1>&2; user-menu; break; fi
done

}

function drq-dir-prompt() {
echo "Download directory: ${ISCP_FILE_ARRAY[file_no]}"
echo  -n "Download(d)/Resume(r)/skip(s)/quit(q)?"
read -n1 answer
if [ -z $answer ]; then echo -e "\nPlease choose an option." 1>&2; drq-dir-prompt; fi
case "$answer" in
d|D)
fresh-dir
;;
r|R)
resume-dir
;;
q|Q)
kill-ssh-agent; echo -e "\nQuitting..." 1>&2; exit 0;
;;
s|S)
echo -e "\nskip directory ${ISCP_FILE_ARRAY[file_no]}";
;;
*)
echo -e "\nPlease choose a valid option" 1>&2; drq-dir-prompt;
;;
esac

}

function drq-file-prompt() {
echo "Download file: ${ISCP_FILE_ARRAY[file_no]}"
echo  -n "Download(d)/Resume(r)/skip(s)/quit(q)?"
read -n1 answer
if [ -z $answer ]; then echo -e "\nPlease choose an option." 1>&2; drq-file-prompt; fi
case "$answer" in
d|D)
fresh-file
;;
r|R)
resume-file
;;
q|Q)
kill-ssh-agent; echo -e "\nQuitting..." 1>&2; exit 0;
;;
s|S)
echo -e "\nskip file ${ISCP_FILE_ARRAY[file_no]}";
;;
*)
echo -e "\nPlease choose a valid option" 1>&2; drq-file-prompt;
;;
esac

}


function fresh-dir() {
echo -e "\nFresh directory download: ${ISCP_FILE_ARRAY[file_no]}"

#if old dir exists then remove it
if [ -d "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ]; then echo -n "removing existing directory..."; rm -r  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ; echo "starting download..."; fi

if [ -z $ISCP_QUOTE ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | sed 's/ /\\ /g' | sed 's/(/\\(/g' | sed 's/)/\\)/g')
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi


if [ ! -z $ISCP_BW_LIMIT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT" | sed 's/--bwlimit=//g')KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT" $ISCP_BW_LIMIT $ISCP_QUOTE --port $ISCP_PORT --progress --recursive --partial "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "Directory Transfer failure...retrying" 1>&2; fresh-dir; fi
}

function resume-dir() {
echo -e "\nResume directory download: ${ISCP_FILE_ARRAY[file_no]}"

if [ -z $ISCP_QUOTE ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | sed 's/ /\\ /g' | sed 's/(/\\(/g' | sed 's/)/\\)/g')
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi

if [ ! -z $ISCP_BW_LIMIT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT" | sed 's/--bwlimit=//g')KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT"  $ISCP_BW_LIMIT $ISCP_QUOTE --port $ISCP_PORT --progress --partial --recursive  "$ISCP_ESC_SOURCE"  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "Directory Transfer failure...retrying" 1>&2; resume-dir; fi
}

function fresh-file() {
echo -e "\nFresh file download: ${ISCP_FILE_ARRAY[file_no]}"

#if old file exists then remove it
if [ -f "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ]; then echo -n "removing existing file..."; rm  "${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]}" ; echo "starting download..."; fi

if [ -z $ISCP_QUOTE ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | sed 's/ /\\ /g' | sed 's/(/\\(/g' | sed 's/)/\\)/g')
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi

if [ ! -z $ISCP_BW_LIMIT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT" | sed 's/--bwlimit=//g')KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT"  $ISCP_BW_LIMIT $ISCP_QUOTE --port $ISCP_PORT --progress --partial "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "File Transfer failure...retrying" 1>&2; fresh-file; fi
}

function resume-file() {
echo -e "\nResume file download: ${ISCP_FILE_ARRAY[file_no]}"

if [ -z $ISCP_QUOTE ]; then
#fix file/directory names with spaces and () by escaping them, we could avoid this by using rsync -s option, but remote server may not have option
ISCP_ESC_SOURCE=$( echo "${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}" | sed 's/ /\\ /g' | sed 's/(/\\(/g' | sed 's/)/\\)/g')
else
ISCP_ESC_SOURCE="${ISCP_SOURCE}${ISCP_FILE_ARRAY[file_no]}"
fi


if [ ! -z $ISCP_BW_LIMIT ]; then echo "Bandwidth limit:$(echo "$ISCP_BW_LIMIT" | sed 's/--bwlimit=//g')KB/s"; fi
rsync --rsh="ssh -p $ISCP_PORT"  $ISCP_BW_LIMIT $ISCP_QUOTE --port $ISCP_PORT --progress --partial  "$ISCP_ESC_SOURCE" "${ISCP_TARGET_DIR}"
# if rsync fails and user specified --retry retry rsync command indefinitely
if [ $ISCP_RETRY -eq 1 -a $? -ne 0 ]; then echo "File Transfer failure...retrying" 1>&2; resume-file; fi
}
#end functions

#start program

#cycle through commandline arguments
for ((i=1; i<=$#; i++))
do

#check for sourcedir and target dir arguments
if [ $(($# - 1)) -eq $i -a $(echo ${!i} | cut -c1,2 ) != "--" -a $(echo ${!#} | cut -c1,2) != "--" ]; then ISCP_SOURCE=${!i}; i=$((i+1)); ISCP_TARGET_DIR=${!i}; fi
#j=$(($# -1))
#if [ $(echo ${!j} | sed 's/[^-]//g' | wc -m) -ne 3 -a $(echo ${!#} | sed 's/[^-]//g' | wc -m) -ne 3 ]; then ISCP_SOURCE=${!j};  ISCP_TARGET_DIR=${!#}; fi

#check for --resume argument
if [ ${!i} == "--resume" ]; then ISCP_RESUME=1; fi

#check for --help argument
if [ ${!i} == "--help" ]; then usage; fi 

#check for --port argument
if [ ${!i} == "--port" ]; then i=$((i + 1)); 
if [ -z ${!i} ]; then echo "Error: Port number not specified!" 1>&2 ; usage; fi
if [ $( echo "${!i}" | grep -Ec '^[0-9]+$') -ne 1 ]; then echo "Error: Port number is invalid!" 1>&2; usage; fi
ISCP_PORT=${!i}; 
fi

#check for --bwlimit argument
if [ ${!i} == "--bwlimit" ]; then i=$((i +1));
if [ $( echo "${!i}" | grep -Ec '^[0-9]+$') -ne 1 ]; then echo "Error: Bandwidth limit is invalid!" 1>&2; usage; fi
ISCP_BW_LIMIT="--bwlimit=${!i}"
fi

#check for --quote argument
if [ ${!i} == "--quote" ]; then ISCP_QUOTE="--protect-args"; fi

#check for identity argument
if [ ${!i} == "--ssh-agent" ]; then ISCP_SSH_AGENT=1;
#see if next argument is the identity file or another option
i=$((i+1))
j=$((i+1))
if [ "$(echo ${!i} | cut -c1,2)"  != "--" -a ! $i -gt $# -a ! $j -eq $# ]; then 
#take IDENTITY_FILE parameter only if in correct place
ISCP_IDENTITY_FILE=${!i}
else
i=$((i-1))
fi
unset j
fi

#check for retry option
if [ ${!i} == "--retry" ]; then ISCP_RETRY=1; fi


done
#command line parameter parsing finished

#add check for ssh, rsync
if [ $(which ssh | wc -m) -eq 0 ]; then echo "Error: ssh command cannot be found in PATH, it may not be installed." 1>&2; exit 1; fi
if [ $(which rsync | wc -m) -eq 0 ]; then echo "Error: rsync cannot be found in PATH, it may not be installed." 1>&2; exit 1; fi


#load ssh-agent if needed
if [ $ISCP_SSH_AGENT -eq 1 ]; then
echo -n "Loading ssh-agent..."
eval `ssh-agent -s` #load ssh agent
echo -n "Loading identities..."; if [ -z $ISCP_IDENTITY_FILE ]; then echo "Defaults"; else echo $ISCP_IDENTITY_FILE; fi
ssh-add $ISCP_IDENTITY_FILE #load identity file, if blank ssh-add takes user defaults
if [ $? -ne 0 ]; then kill-ssh-agent; fi
fi

#change IFS to allow filenames/directory names with spaces to processed
IFS=$'\n'

#append trailing slash to source dir and target dir if necessary
if [ $( echo "$ISCP_SOURCE" | grep -c "/$") -eq 0 ]; then ISCP_SOURCE=${ISCP_SOURCE}/ ; fi
if [ $( echo "$ISCP_TARGET_DIR" | grep -c "/$") -eq 0 ]; then ISCP_TARGET_DIR=${ISCP_TARGET_DIR}/ ; fi

#check format of ISCP_SOURCE is correct (only a rough check)
if [ $( echo "$ISCP_SOURCE" | grep -Eci '^([a-z0-9_-]+@)?[0-9a-z.-]+:[0-9a-z/ ]+$') -ne 1 ]; then echo "Error: source directory is invalid, format must be [user@]hostname:/path/to/directory" 1>&2; exit; fi

#check target directory exists
if [ ! -d "$ISCP_TARGET_DIR" ]; then echo "Error: target directory does not exist" 1>&2; exit 1; fi
#check target directory is writable
if [ ! -w "$ISCP_TARGET_DIR" ]; then echo "Error: target directory is not writable" 1>&2; exit 1; fi


#get ISCP_SOURCE_SERVER & ISCP_SOURCE_DIR
ISCP_SOURCE_SERVER=$(echo "$ISCP_SOURCE" | sed 's/:.*//g')
ISCP_SOURCE_DIR=$(echo "$ISCP_SOURCE" | sed 's/.*://g')

#############main begin

#get directory listing from remote server
echo "Connecting to $ISCP_SOURCE_SERVER on port $ISCP_PORT in ${ISCP_SOURCE_DIR}"


#get ls listing & size with single ssh command
#cycle through elements and create array
i=0
j=0
for fod in $(ssh -p $ISCP_PORT $ISCP_SOURCE_SERVER "ls -F $ISCP_SOURCE_DIR ; echo '##END-LS##'; cd $ISCP_SOURCE_DIR ; du --si --max-depth=0 *")
do
if [ $fod == "##END-LS##" ]; then ISCP_TICK=1; continue;fi

#extract ls -F command
if [ $ISCP_TICK -eq 0 ]; then
ISCP_FILE_ARRAY[i]=$fod
i=$((i+1))
fi

#extract du --si --max-depth=0 command
if [ $ISCP_TICK -eq 1 ]; then
ISCP_FILE_SIZE_ARRAY[j]=$(echo "$fod" | awk '{print $1}' )
j=$((j+1))
fi

done


#check to see we actually found stuff to download
if [ ${#ISCP_FILE_ARRAY[*]} -eq 0 ]; then echo "Error: Nothing to Download!" 1>&2; kill-ssh-agent ; exit 1; fi


#show user menu 
user-menu

# ISCP_USER_CHOICE now contains a list of the indicies to use in ISCP_FILE_ARRAY, cycle through them and take appropriate action
for (( i=0; i<= ${#ISCP_USER_CHOICE[*]} -1; i++))
do
file_no=${ISCP_USER_CHOICE[i]}
echo "Download : ${ISCP_FILE_ARRAY[file_no]}"

#decide if we are dealing with a file or directory
if [ $( echo ${ISCP_FILE_ARRAY[file_no]} | grep -c '/$') -eq 1 ]; then
##directory download

#check if directory already exists in target directory
if [ -d ${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]} ]; then
#directory already exists on local system

#decide to use user input if --auto is set to 0
if [ $ISCP_RESUME -eq 1 ]; then resume-dir; else
#bring up prompt to ask user what to do
drq-dir-prompt
fi

else
#directory in new do freshdir download
fresh-dir
fi

##end directory download
else
##file download

#check if file already exists in target directory
if [ -f ${ISCP_TARGET_DIR}${ISCP_FILE_ARRAY[file_no]} ]; then
#file already exists on local system

#decide to use user input if --auto is set to 0
if [ $ISCP_RESUME -eq 1 ]; then resume-file; else
#bring up prompt to ask user what to do
drq-file-prompt
fi

else
#file is new do freshfile
fresh-file
fi



##end file download
fi

done

echo "Done..."
###############main end

#kill ssh-agent if it was invoked
kill-ssh-agent
